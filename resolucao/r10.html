<html>
    <head>
        <!--
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <meta http-equiv="refresh" content="15">
        -->
        <link rel="stylesheet" href="css/bootstrap.min.css">
        <script src="js/polyfill.js"></script>
        <script id="MathJax-script" async src="js/tex-mml-chtml.js"></script>
        
    </head>
    <body>

    <!---------------------------------------------------------------------------------------------------------------------->

    <h4>Algoritmos gulosos</h4>
    
    <h5>Resolução - Questão 1</h5>
    
    <ol type="a">
        
        <li>
<pre>
<code>
# pre-condicao:	listaA e listaB, listaA = um possível sub conjunto de listaB
# pos-condicao: tamanho da sequencia
#               lista dos indices da listaB a serem removidos
    
def prefixo_subsequencia(listaA, listaB):
    # variavel iterativa
    tamanho_sequencia = 0

    # armazenagem dos indices a serem removidos
    lista_indices_remocao = list()
    
    # para cada item na listaB (lista maior ou igual a listaA)
    for indice in range(len(listaB)) : 

        # verifica se o contador tem o mesmo
        # tamanho da listaA (lista menor ou igual listaB)
        # se tiver, não é mais necessário verificar
        # pois a lista já foi totalmente verificada
        if (tamanho_sequencia == len(listaA)): 
            break
            
        # para cada ocorrencia do mesmo termo em 
        # listaA e listaB, incremente a quantidade
        # correspondente ao tamanho da sequencia
        if (listaB[indice] == listaA[tamanho_sequencia]) : 
            tamanho_sequencia = tamanho_sequencia + 1
        # adiciona a lista o indice que deve ser removido de listaB
        else:
            lista_indices_remocao.append(indice)
                
    
    return tamanho_sequencia , lista_indices_remocao
</code>    
</pre>
        </li>
        
        <!-- O invariante do loop afirma que existe prefixo-subsequência ótimo consistente com as escolhas s[1..i−1] que foram feitas antes da iteração i. Mostre que o código do loop mantém este invariante na i-ésima iteração. -->
        <li>
            <p>
                Podemos provar o invariante do loop de forma indutiva:
            </p>
            <ul>
                <li>Quando \( i = 0 \) (com uma lista de um elemento), a solução ótima é estabelecida, pois a comparação entre <code>listaA[0] == listaB[0]</code>, retorna <code>true</code> ou <code>false</code>. Isso significa que se não for a solução ótima, não é uma solução; </li>
                <li>Quando \( i > 0 \), temos a solução para a configuração de um índice da lista em \( {1, 2, ..., i} \), acrescido da soluçaõ ótima anterior. </li>
                <li>Esse procedimento reúne as sub-soluções ótimas vindas das iterações anteriores e organiza uma solução completa para o problema na última iteração. </li>
                <li>É interessante observar que o algoritmo evita o cálculo das soluções quando se encontra o melhor resultado na análise da <code>listaA</code></li>
            </ul>
        </li>
    </ol>

    <h5>Resolução - Questão 2</h5>

    <ol type="a">
        <li>
        </li>

        <li>
        </li>

        <li>
        </li>
    </ol>
    <!---------------------------------------------------------------------------------------------------------------------->

    </body>
</html>


